# 《Microservices in Action》阅读笔记

* 第一部分总体介绍微服务，浏览基于微服务的系统的特征和好处，以及开发过程中面临的挑战
* 第二部分微服务应用的架构和设计
* 第三部分介绍微服务的最佳发布实践

微服务的优缺点（https://martinfowler.com/microservices/）：

* 强模块边界
* 独立部署
* 技术多样性

* 分布式系统更难开发，远程调用速度慢，风险高
* 分布式系统中的一致性更难保持
* 操作复杂，需要成熟的运维团队管理大量的服务，需要经常性的发布

## 1. Designing and running microservices

与单个庞大的统一系统不同，微服务有多个松耦合、自主服务组成，每个服务专注一件事。
（有点类似模块化设计，每个模块完成一个功能；或者类似Java里程序设计原则，每个类或方法只负责处理一件事。）

这样可以使系统具有更好的可维护性。对于旧应用系统的改造也可以采用一个一个功能的拆解，独立成微服务。

为了交付有价值的微服务，团队不能只关注于程序的构建，还需要多项操作技能：

* deployment 部署
* observation 观察
* diagnosis 诊断

### 1.1. 什么是微服务应用？

微服务应用是一组自主服务集合，每个服务专注做好一件事，所有服务共同协作完成更复杂的操作。

服务之间通过技术无关的消息协议进行通信，点对点或异步。

Cohesion & Coupling

> Gather together the things that change for the same reasons. Separate those things that change for different reasons.

单个微服务应该是高内聚的：

> 它在一个应用中只负责单一的功能。

每个服务很少知道其他服务的内部逻辑，这样单个服务发生变化时，不会强迫要求其他服务也发生变化。

微服务的三个特征：

* 每个微服务负责单一的功能
* 一个微服务只拥有它自己的数据存储（如果有的话），这样可以降低服务之间的耦合，其他服务只能通过该服务提供的接口来访问数据
* 微服务自己（而不是微服务间的消息传输机制），负责安排和协调消息的顺序和执行某些有用活动的操作

另外的两个基础特征：

* 每个微服务可以单独部署，如果不能单独部署，微服务应用和单个大应用就没什么区别了
* 一个微服务是可以被替换的。单一功能自然限定了它的大小边界，也使得它的职责、角色容易被理解

#### 1.1.1. Scaling through decomposition 通过分解进行扩展

Abbott and Fisher three dimensions of scale:

* X-axis: 水平复制，单一大应用，重复发布多个实例
* Y-axis: 微服务正相反，拆解系统，不同功能根据需要进行扩展
* Z-axis: 水平数据分区--sharding（分片），微服务和单一大型应用都会用到

微服务应用的技术特性：

* 单一功能的服务构建，设置了自然的大小和责任边界
* 自主性使得服务可以独立开发、部署、扩展

#### 1.1.2. Key principles 关键原则

微服务开发的五个架构原则：

* Autonomy 自治
* Resilience 弹性
* Transparency 透明性
* Automation 自动化
* Alignment 统一

由这些原则驱动技术和组织在构建和运行微服务应用时作出选择。

##### Autonomy

> autonomous: each service operates and changes independently of others.

设计目标：

* Loosely coupled 松耦合，服务间通过明晰的接口或事件进行通信，无需关注对方的内部实现
* Independently deployable 可独自发布，服务可由多个团队并行开发，快速、频繁小版本发布

Autonomy也是一种文化（cultural），团队要为自己所有的服务负责，包括开发和生产。

##### Resilience 快速恢复能力，弹性

微服务可以隔离故障，只影响系统的局部。

虽然微服务可以隔离故障，但也可能导致多点故障，所以需要有可靠的持续交付技术和完善的系统活动监控机制，来定位故障的具体位置。

##### Transparency 透明

当故障出现时，应该对整个系统，而不是单个服务可见。
应用中的每个服务都将产生业务、操作、应用日志信息，请求轨迹，来跟踪服务的状态。

##### Automation 自动化

微服务架构设计比单个应用更复杂，通过自动化，寻求服务间的基础设施一致性，降低管理的复杂度。需要使用自动化来确保发布和系统操作的正确性。

微服务架构和DevOps技术的并行流行并非偶然。

DevOps 
> is a set of practices that combines software development (Dev) and information-technology operations (Ops) which aims to shorten the systems development life cycle and provide continuous delivery with high software quality.

> DevOps是Development和Operations的组合，是一种方法论，是一组过程、方法与系统的统称，用于促进应用开发、应用运维和质量保障（QA）部门之间的沟通、协作与整合。以期打破传统开发和运营之间的壁垒和鸿沟。 DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。具体来说，就是在软件交付和部署过程中提高沟通与协作的效率，旨在更快、更可靠的的发布更高质量的产品。


##### Alignment

SOA架构是水平拆分，分为多层，每层的多个功能混在一起，容易导致在同一层中不同功能耦合度过高。

而微服务架构是垂直拆分，每个服务完成一个单独的业务功能，把相关各层封装在一起。

注：极少数情况下，需要将第三方服务统一封装到一个服务中，为其他服务提供支持。

还需要考虑服务的使用方（Consumers），确保向后兼容性，可以使用以下两种方式：

* 程序中显式控制向后兼容
* 运行多版本

不能强制其他团队升级或中断服务。

#### 1.1.3. Who uses microservices?

很多大公司最初都是提供一个庞大的单一解决方案，为了应对快速增长的压力，逐渐开始向微服务迁移。压力主要来自以下几方面：

* Volume 量级，业务量超出原始的技术选型的承载能力
* New Features 新功能，新功能无法与已有功能协同工作，或者需要使用不同的技术来解决问题
* Engineering team growth 研发团队成长，当一个团队变得很大时，沟通线拉的很长，新的开发成员需要花费更多时间来理解现有的系统，这样就导致了生产效率的降低
* Technical debt 技术债，随着系统复杂性的升高，以前留下的技术债越来越多，导致越来越难以修改
* International distribution 国际化分布式，导致数据的一致性、可用性和低延迟面临挑战

#### 1.1.4. 为什么微服务是个好的选择？

* 技术异质性（多样性），不同的功能可能使用不同的技术实现，微服务策略可以有更多的技术选择
* 随着复杂系统的成长，开发矛盾开始加剧

factors may lead to friction:

* 变更周期耦合到一起，导致增加协调障碍和高风险
* 软件模块和边界模糊导致团队之间耦合度过高
* 单一的大型程序持续集成困难，编译慢、启动慢

微服务可减少矛盾（Friction）和风险（Risk），三种方法：

* 构建时隔离、最小化依赖关系
* 允许开发者思考单个组件的内聚性，而不是整个系统
* 允许小的，独立的变化持续交付

### 1.2. 微服务的挑战是什么？

* 划分和确认微服务范围需要丰富的领域知识（domain knowledge）
* 服务间的边界和关系很难划分，一旦确立之后，修改又很耗时
* 微服务是分布式系统，需要承担一致性、网络可用性
* 跨网络分布的系统组建和技术异质性，使得微服务引入了新型故障
* 理解和验证正常操作会发生什么变得更有挑战

#### 1.2.1. 设计挑战

#### 1.2.2. 操作挑战

### 1.3. 微服务开发周期

微服务应用开发周期：

* 设计服务
* 发布到生产环境
* 观察服务的运行情况

#### 1.3.1. 设计微服务

需要考虑的问题：

* 是否先从一个单一系统（monolith）开始，再承诺将来向微服务过度
* 应用的总体架构，和它将展现给外部消费者的一面
* 如何标识和划分服务范围
* 服务间如何通信，同步还是异步
* 如何实现服务的弹性

#### 1.3.2. 发布微服务

开发和运行必须紧密结合在一起，开发者直接发布服务，并观察服务的运行状况，才能更好的理解设计。

* 标准化微服务部署工作
* 实现持续交付管道

##### 标准化微服务部署工作

Python -- Fabric
Ruby -- Capistrano
Elixir -- exrm

* 应用程序运行在什么样的服务器上？
* 应用程序依赖哪些工具？
* 如何启动应用程序？

如果不能对服务部署进行标注化，会增加部署的管理成本，最后每个团队都在重复造轮子，使用不同的管理工具、构建工具和发布方法。

container： 操作系统级的虚拟化方法，运行一个完全隔离的系统，有其自己的host、网络和进程空间。

container容器比虚拟机更快的构建和启动，可以在一个机器上启动多个容器，简化本地开发，优化云环境资源利用。

容器为应用程序提供了表转化的打包、运行时接口，还提供了操作环境和代码的不可变性。

container的类型：

* jails - in FreeBSD
* zones - in Solaris
* Docker - 更成熟

##### 实现持续交付管道

持续交付（CD）需要关注的两个目标：

* 构建软件必须通过的一组验证，发布的每个阶段，都应该能够证明代码的正确性
* 将从commit到production整个管道自动化

#### 1.3.3. Observing microservices

* 找出系统中脆弱的部分并重构
* 理解系统如何运转

在微服务应用中完全的监控是非常困难的，因为单个事物会涵盖多个不同的服务；
异构服务可能产生不协调的格式的数据；
运行日志数据量庞大；

##### 识别并重构系统中潜在的脆弱实现

## 1.4. Responsible and operationally aware engineering culture

Conway's Law

按照要构建的系统的架构去设计组织结构。

组织要适应微服务架构方法的需要。

### Summary

微服务既是一个架构风格，又是一套实践文化，五个基本原则


## 2. Microservices at SimpleBank


#### 2.2.2. Reducing friction and delivering sustainable value


### 2.3. Building a new feature

构建新功能需要回答的问题：

* 想构建哪些服务？
* 这些服务如何互相协作？
* 如何把他们的功能暴漏给外部世界？

key iterative stages:

* design
* deploy
* observe

#### 2.3.2. 服务合作

服务间合作方式：

* 点对点--同步
* 事件驱动--异步

很多微服务应用开始时都是用同步方式通信，其动力是：

* 同步调用相对简单
* 开发语言生态系统可能已经支持交换机制，如：HTTP

#### 2.3.3. Service choreography

在微服务应用中，服务通常具有不同级别的响应，在orchestration和choreography之间应该达到一个平衡。

choreographed系统中，一个服务不需要直接命令、触发其他服务中的操作，而是每个服务拥有其特定的责任，通过响应其他事件来执行。

### 2.4. exposing services to the world

构建API网关，为客户端提供服务。

### 2.5. Taking your feature to production

#### 2.5.1. 质量控制和自动部署

传统的组织通过控制和管理变化，来减少bug，但在微服务架构下，这种方法不起作用，因为系统将是持续演进的。

解决方法是需要标准化和自动化：

* 对开发过程标准化，代码审查、编写合适的测试、版本控制
* 对部署过程标准化和自动化，最小化工程师干预

#### 2.5.2. Resilience

微服务风险点：

* 硬件
* 服务间通信
* 依赖

#### 2.5.3. Transparency

构建完善的日志监控系统，将系统关键位置的日志信息归集到日志分析查询系统，如ELK (Elasticsearch, Logstash, Kibana)，可在出现问题时，进行检索定位。

思考问题：系统需要有一个统一标准的、格式化的日志规范：采集哪些字段？采集频率？等等，是否可以考虑封装一个统一的日志中间件？

Prometheus -- 开源监控系统，trigger alerts and build health dashboards for microservices.

### 2.6. Scaling up microservice development

* technical divergence
* isolation

#### 2.6.1. 技术分歧

每个技术团队都有自己喜好的开发语言、工具、发布脚本和设计原则，以及第三方库。

在整个项目中统一标准很重要。

#### 2.6.2. Isolation

### 2.7. What's next?

### Summary

服务监控包括日志聚合和服务级别的健康检查

微服务会因为硬件、通信和依赖关系而失败，不仅仅是因为代码

随着服务数量的增长，工程师组织中的技术分歧和孤立也开始面临挑战。

为了避免技术分歧和孤立，需要制定跨多个项目组的标准和最佳实践。

## 3. 微服务应用架构

涵盖的内容：

* 微服务应用俯视图
* 微服务架构的四个层级--平台、服务、边界、客户端
* 服务通信模式
* 设计API网关和消费者驱动切面作为应用的边界

### 3.1. 整体架构

#### 3.1.2. 架构师的角色

架构师应该在两方面指导开发：

* Principles 准则，能够帮助团队达到技术和组织目标的指导方针
* Conceptual models 概念模型，系统级的关系，应用级的模式

#### 3.1.3. 架构准则

Principles应该具有灵活性，能够适应业务需求的优先级，和应用技术演进。如早期开发验证市场契合度具有更高优先级，而对于成熟的应用应该重点关注性能和可扩展性。

#### 3.1.4. 微服务应用的四个层级

* Platfrom -- 微服务平台提供工具、基础设施，支持快速开发、操作、发布微服务，完善的平台层可以保证工程师专注于构建业务功能
* Services -- 构建与平台层之上的服务
* Boundary -- 定义边界与客户端交互
* Client -- 客户端应用，例如网站、移动应用，与微服务后端交互

### 3.2. A microservice platform

支持微服务的基础设施：

* 运行微服务的发布目标，如负载均衡、虚拟机
* 日志和监控聚合，用于观察服务的运行状况
* 一致的、可重复的发布管道，用于测试和正式发布新服务或新版本
* 安全操作支持，包括网络控制、安全管理和应用加固
* 沟通渠道和服务发现，用于服务间的交互

### 3.3. Services

#### 3.3.1. Capabilities

business capability：组织要创造的价值，达到商业目标。

technical capability：实现共享的技术功能，支持其他服务。

### 3.4. Communication

#### 3.4.1. 什么时候使用同步消息

选择传输方式：

* RESTful HTTP
* RPC


传输方式要与业务逻辑分开，这样将来可以替换别的传输方式。

同步消息的缺点：

* 导致服务间的紧耦合
* 没有广播、发布-订阅模型，限制了工作并发执行的能力
* 等待回应时需要锁定代码执行。在多线程或多进程服务器模型中，容易触发级联故障
* 过度使用同步消息，会导致深度依赖连

#### 3.4.2. 什么时候使用异步消息

异步消息更灵活。上下游影响小。

异步通信比较难以推断问题的原因，需要在监控运行上投入更多，来追踪系统的行为。

异步消息通常需要通信代理人，一个独立的系统组件，可以接收实践，分发事件给消费者，有时也被称为事件中枢（event backbone），如：

* Kafka -- 高吞吐量，replayable event storage
* RabbitMQ -- 高级别消息中间件
* Redis -- 

#### 3.4.3. 异步通信模式

两种常用的基于事件的模式：

* job queue -- job只被处理一次，winner takes all
* publish-subscribe

#### 3.4.4. 定位其他服务

服务发现（service discovery），平台层应该提供这种能力，便于服务间的通信。

### 3.5. 应用边界

边界层可以实现一些面向客户端的功能：

* 认证和授权
* 控制访问频率
* 缓存
* 收集日志和指标

应用边界的三种不同模式（patterns）：

* API网关
* 后端与前端
* consumer-driven网关

#### 3.5.1. API网关

API网关为客户端提供访问后端服务的唯一入口，作为底层服务的代理。

#### 3.5.3. Consumer-driven gateways

使用GraphQL查询语言指定API要返回的数据字段。

参考：

* http://graphql.org/
* https://www.apollographql.com/

### 3.6. 客户端

#### 3.6.1. Frontend monoliths

#### 3.6.2. 微前端

## 4. 设计新功能

设计新功能时需要考虑的问题：

* 什么时候构建新的服务
* 什么时候扩展已有的服务
* 这些服务间的边界是什么
* 这些服务如何协作

设计良好的服务的三个关键特征：

* 只负责单一功能
* 独立发布
* 可替换的

### 4.1. SimpleBank的一个新功能

设计新功能大的四个步骤：

* 理解业务问题，用例，和可能的解决方案
* 确认业务应该支持的不同实体和业务功能
* 按照功能划分业务
* 根据当前和未来的需求，验证设计的合理性

### 4.2. 按业务能力界定范围

service coping -- decomposition/partitioning

业务拆分的三个策略：

* 依据业务能力或上下文环境边界
* 依据用例
* 依据不稳定性

### 4.3. 按用例界定范围

#### 4.3.2. Actions and stores

为了避免掉入过度设计的陷阱，导致过多的远程调用和过长的服务链调用，推荐设计微服务时，在构建细粒度的面向动作的服务之前，先构建粗粒度服务能力。

#### 4.3.3. Orchestration and choreography

### 4.4. Scoping by volatility

好的架构应该在当前和未来需求间达到一个平衡。

### 4.5. 技术能力

#### 4.5.1. 发送通知

#### 4.5.2. 什么时候使用技术能力

* 在面向业务的服务中包含某capability时会使得服务过于复杂
* 一个技术能力被多个服务需要（如发送邮件通知）
* 技术能力可以独立于业务能力进行修改，如第三方集成

### 4.6. 处理歧议

构建微服务应用时，推荐采用迭代和精益（lean）开发过程。

#### 4.6.1. 从粗力度服务开始

当怀疑服务边界时，最好构建大一点的服务。

如果服务太小，可能导致在不同的服务间耦合度过高，这样的服务应该合并成一个服务。

principle of lean software development: decide as late as possible

#### 4.6.2. 为将来的分解做准备

为模块边界定义清晰的公开API，但需要注意的是：代码库中好的API并不一定适合作为微服务的接口。

#### 4.6.3. Retirement and migration

迁移服务的步骤：

* 先将目标功能拉入一个新服务
* 将消费者从旧服务迁移到新服务
* 在原服务中删除废弃的代码

### 4.7. Service ownership in organizations

跨团队的服务交互可能出现的三种情况：

* Limited control 受限的控制
* Design constraints 设计约束
* Multispeed development 多种开发速度

面对这些挑战的应对策略：

* Openness 保证所有工程师可以修改查看和修改所有代码，帮助不同团队间互相理解对方工作
* Explicit interfaces 提供明确的、文档化的接口，降低沟通成本
* Worry less about DRY（don't repeat yourself）
* Clear expectations 明确的预期--性能、可用性、特性

## 5. 微服务中的事物和查询

本章覆盖的内容：

* 分布式应用中数据一致性的挑战
* 同步和异步通信
* 使用sagas开发跨多服务的业务逻辑
* 用于微服务查询的API组合和CQRS

### 5.1. 分布式应用中的一致性事务

ACID是衡量事务的四个特性：

* 原子性（Atomicity，或称不可分割性）
* 一致性（Consistency）
* 隔离性（Isolation）
* 持久性（Durability）

按照严格的标准，只有同时满足ACID特性才是事务。

#### 5.1.1. 为什么不能使用分布式事务？

### 5.2. 基于事件的通信

eventual consistency 最终一致性

#### 5.2.1. Events and choreography

choreographed: 每个服务依据事件作出反应，独自运行，不需要了解整个过程的结果。

Events and the monolith:

面向事件的通信方式，在从单一大系统迁移到微服务应用时，有着至关重要的作用。

### 5.3. Sagas

saga pattern：

* 互相协作的一系列本地事物
* 前一步触发saga中的下一步动作


A saga is a sequence of local transactions. Each local transaction updates the database and publishes a message or event to trigger the next local transaction in the saga. If a local transaction fails because it violates a business rule then the saga executes a series of compensating transactions that undo the changes that were made by the preceding local transactions.

> ref: https://microservices.io/patterns/data/saga.html

There are two ways of coordination sagas:

* Choreography - each local transaction publishes domain events that trigger local transactions in other services（消息类型：event）
* Orchestration - an orchestrator (object) tells the participants what local transactions to execute（消息类型：command）

#### 5.3.1. Choreographed sagas

每一个动作都是为了响应其他事件而执行，没有一个整体的指挥者或安排者。

语义上的回滚，二不是数学上的一致性。

优点：

* 服务之间不需要互相了解，保证了松耦合，加强了每个服务的独立性。

缺点：

* 一个完整功能要跨越多个服务
* 增加了状态管理的复杂度
* Choreoraphy 引入了服务间的循环依赖

如果选择异步消息方式，必须在监控和跟踪方面投入更多，来追踪系统的执行流程。

#### 5.3.2. Orchestrated Sagas

在Orchestrated Saga方式中，一个服务充当orchestrator（coordinator）的角色。

orchestrator管理saga执行，与参与者之间的交互既有异步事件，也有reqeust/response消息。

优点：

* 逻辑在单一的服务里，容易推断结果
* 简化单一的服务，减少复杂的状态管理

缺点：

* 业务逻辑过多集中于协调者中，其他服务缺少对数据存储的封装

#### 5.3.3. Interwoven Sagas

#### 5.3.4. 一致性模式

处理失败的两种模式：

* 补偿操作（退款）
* 重试

#### 5.3.5. 事件源

### 5.4. Queries in a distributed world

分页、同时查询多个ID

#### 5.4.1. Storing copies of data

在服务中缓存从其他服务接收到的数据，风险：

* 管理数据的多个拷贝，增加应用和服务的复杂度
* 事件中的数据结构变化很难管理，导致服务与事件内容之间耦合
* 让缓存失效很苦难

#### 5.4.2. 分离查询和命令

CQRS -- command-query responsibility segregation 命令-查询责任分离

##### CQRS架构

CQRS提供的两个关键优点：

* 为特定的查询优化查询模型，提高性能，移除对跨服务联合查询的依赖
* 有助于从服务和应用层分离concerns

#### 5.4.3. CQRS的挑战

需要考虑最终一致性--replication lag 复制滞后

三种策略：

* optimistic updates
* polling
* publish-subscribe

#### 5.4.4. Analytics and reporting

### 5.5. Further reading

《Reactive Application Development》, by Duncan K. DeVore, Sean Walsh, and Brian Hanafee
《Microservices Patterns》, by Chris Richardson
《Event Streams in Action》, by Alexander Dean

## 6. 设计可靠的服务

* 服务可用性对应用可靠性的影响
* 设计微服务来防止依赖中的错误
* 采用重试、速率限制、断路器、健康检查和缓存，以缓解服务间通信问题
* 在多服务中应用安全的通信标准

service availability 服务可用性

### 6.1. Defining reliability

三个目标：

* 减少可避免错误的发生
* 限制不可预知的错误的级联和系统范围的影响
* 快速恢复，当错误出现时，最好能自动化恢复。

实现这些目标，来确保服务最大化运行时间和可用性。

### 6.2. 什么会出错？

需要理解应用中可能出现的不同类型的错误。

在风险和成本之间达到一个平衡

#### 6.2.1. 失败的源头

最可能出现问题的地方：

* 硬件
* 通信，服务之间，和第三方之间
* 依赖
* 服务内部，代码错误

##### 硬件

缓解影响的方法：不同级别的冗余（同时需要考虑成本）

##### 通信

网络、防火墙、DNS错误、消息系统错误、健康检查失败

通常是由人为干预导致的，如发布新版本服务、配置修改，最好的方法就是确保配置修改经过强力测试，并且当问题出现时易于回滚。

##### 依赖

超时、未考虑兼容、内部组件失败、外部依赖

##### Service Practices

开发和发布服务可能导致失败：

* 设计缺陷
* 测试不充分
* 发布错误

#### 6.2.2. 级联失败（Cascading failures）

### 6.3. 设计可靠的通信

当协作者不可用时，最大化正确操作的方法：

* 重试
* 后备、缓存、适度降级
* 超时和最后期限
* 断路器（Circuit Breakers）
* 通信代理人

#### 6.3.1. 重试

重试可能放大失败的影响。

exponential back-off 指数退回策略

随机生成一个等待重试的时间间隔，避免固定的重试间隔批量调度影响。

重试可以有效解决依赖失败问题，但在使用时要格外小心，避免使问题恶化：

* 限制最大重试次数
* 使用exponential back-off策略，使重试请求平滑分布，避免加剧过载
* 考虑哪些错误条件应该触发重试，哪些不需要重试

#### 6.3.2. 后备（Fallbacks）

四个备用选项：

* 适度降级
* 缓存
* 功能冗余
* 存根数据

#### 6.3.3. 超时

#### 6.3.4. 断路器

#### 6.3.5. 异步通信

### 6.4. 最大化服务可靠性

* 健康检查
* 速率限制

#### 6.4.1. 负载均衡和服务健康

负载均衡的两种角色：

* 标识其下可用于响应请求的实例
* 将请求路由到其下的不同实例

健康检查的两个标准：

* liveness 应用启动并运行着
* readiness 表示服务已准备好可以提供通信

#### 6.4.2. 速率限制

限制服务的请求频率，防止过载。

#### 6.4.3. 验证可靠性和容错

全面测试，保证设计的有效性：

* load testing
* chaos testing

##### 负载测试

* 对服务的预期增长和影响建模，确保理解服务的可能用途
* 估算服务能力需要的容量
* 通过负载测试验证服务发布能力
* 使用业务和服务指标，再次估算能力

##### Chaos Testing

### 6.5. Safety by default

#### 6.5.1. 框架

使用特定库实现服务间标准化交互，有以下好处：

* 避免自己动手实现服务间交互
* 简化回滚处理，优化跨服务间通信
* 清晰的区分开代码中的网络调用和本地调用
* 能够扩展提供支撑功能，如收集服务间交互的指标数据

#### 6.5.2. Service mesh

## 7. 构建一个可重用微服务框架

* 构建微服务基础框架（chassis）
* 强制实行跨团队统一实践的好处
* 将共同关注点抽象成可重用框架

多个团队不易强制实行完全一样的开发工具和语言，容易降低开发数独。
团队可以使用不同的工具或语言，但必须将指标数据按照统一的格式收集到相同的地方。

### 7.1. 一个微服务基础框架

### 7.2. 微服务基础框架的目的是什么？

* 使团队成员更容易上岗
* 更好的理解代码结构和工程师团队使用的技术栈
* 限制生产系统的试验范围
* 帮助遵守最佳实践

通用代码应该包含以下功能：

* 日志
* 配置获取
* 指标收集
* 数据存储配置
* 健康检查
* 服务注册和发现
* 传输相关的样板选择（AMQP，HTTP）

#### 7.2.1. 降低风险

组合语言和库满足特定需要时，减少无法正常运行的机会。
使用已有的，经过验证的基础框架或代码库，构建服务，出错的几率要低于使用不熟悉的、新的框架或代码库。减少开发人员重复造轮子。

#### 7.2.2. 更快的启动

使用微服务基础框架可以更快速的测试、重用，启动服务，节省更多时间。

更快的部署，就可以更快的验证概念、功能的合理性。

降低团队新成员的学习障碍。

### 7.3. 设计一个基础框架（chassis）

#### 7.3.1. 服务发现

round-robin algorithm:

> https://en.wikipedia.org/wiki/Round-robin_scheduling

#### 7.3.2. Observability

#### 7.3.3. 均衡与限制

### 7.4. 浏览用基础框架实现的功能

## 8. 部署微服务

* 为什么在微服务应用中正确部署很重要？
* 微服务生产环境的基础组件
* 部署微服务到公有云
* 将服务打包成一个不可变的artifact

成熟的部署实践对构建可靠的、标准的微服务来说至关重要。
自动化部署对开发微服务是必不可少的。

### 8.1. 部署为什么重要？

部署时软件系统生命周期中风险最高的时刻。

70%的故障是由于运行系统的的修改导致的。

部署微服务时的四个挑战：

* 面对大量的发布和组件修改时保持稳定
* 避免组件间的紧耦合导致构建和发布时互相依赖
* 发布有变化的服务API，会影响服务的客户端
* 退役服务

#### 8.1.1. 稳定性和可用性

* 手动修改管理成本高
* 小版本发布降低风险，增加可预期性
* 自动化驱动部署迅速并能保证一致性

系统故障过程中的抗脆弱性、可恢复性也是应用的稳定性的一个重要元素。

### 8.2. 微服务生产环境

部署是过程和框架的组合：

* 过程包括获取代码、使其能够正常工作，保持其正常工作
* 环境框架用于承载软件运转

运行微服务的生产环境的决定因素：

* 组织者已有的基础设施
* 技术能力
* 应对风险的态度
* 监管要求

#### 8.2.1. 微服务生产环境的特征

微服务生产环境必须具备的六个基础功能：

* 1、一个部署目标或运行时平台
* 2、运行时管理
* 3、日志和监控
* 4、支持安全操作
* 5、负载均衡、DNS等路由模块
* 6、部署管道

#### 8.2.2. 自动化和速度

评估部署平台是否适合微服务应用的两个因素：

* Automation
* speed

### 8.3. 部署一个服务的快速方法

### 8.4. 构建服务工件（artifacts）

直接从代码仓库拉去代码，编译打包部署存存在以下问题：

* 启动应用慢，每个节点都要拉取代码、构建
* 无法保证每个节点上运行相同版本的服务

这导致部署是不可预知的，为此，我们需要构建一个服务工件。

通常，自动构建工具（Jenkins、CircleCI）构建一个服务工件，并将其推送到工件资源库。

#### 8.4.1. 工件（artifact）内部有什么？

一个微服务不只有代码，它有很多组成部分：

* 应用程序代码，编译或者未编译的
* 应用程序库
* 安装在操作系统中的二进制依赖包
* 支持过程（logging or cron）
* 外部依赖，如数据存储、负载均衡，或其他服务

#### 8.4.2. Immutability

部署失败时，可快速恢复到前一个正常状态的artifact。能够保证测试和发布到生产环境的artifact是同一个版本。

#### 8.4.3. 服务工件的类型

* 操作系统级的安装包
* 服务器虚拟机镜像
* 容器

OS包的缺点：

* 增加了不同基础设施的需求，需要管理包资源库
* 依赖的系统包通常与特定的操作系统紧耦合，降低了部署到不同目标的灵活性
* 包需要在主机环境下执行

##### 容器

在一个机器上可以运行多个容器，互相隔离，并且系统资源开销比虚拟主机低，因为他们共享一个操作系统的内核。

容器可移植性强，同一个镜像可运行在不同的基础设施上。可以部署在多个不同的目标，如开发环境。

#### 8.4.4. 配置

服务工件中并不能包含所有配置信息：

* 不应将安全、敏感的配置数据如数据库密码，存储在明文的版本控制系统中。
* 特定环境的配置数据，如数据库URL地址，log级别或者第三方服务。

存储配置信息的两个建议：

* 在版本控制系统中伴随服务存储非敏感配置信息
* 单独的，有严格访问控制的保险库（vault），存储安全信息

### 8.5. Service to host models

三种部署模型：

* single service to host
* multiple services to host
* container scheduling

#### 8.5.1. Single service to host

每个主机一个服务，虚拟主机启动较慢，通常要几分钟

#### 8.5.2. 每个主机多个静态服务

这种方式方式的几个缺点：

* 增加了服务间的耦合度，不同的服务可能依赖不同版本的包。环境信息、所属权容易引起混乱。
* 监控和单独扩展服务面临挑战。不容易监测系统资源的使用情况。

#### 8.5.3. 每个主机多个scheduled服务

容器提供了更完美的抽象：

* 一个工程师可以定义并分发一个完整的应用工件
* 一个虚拟主机可以运行多个独立的容器，互相之间完全隔离
* 容器提供自动化操作API

调度器模型的优点：

* 动态的，依赖于系统资源
* 避免静态模型的陷阱
* 容器模型可以保护服务相互独立

容器调度器--container scheduler--Kubernetes

容器调度器比较复杂，如果对Kubernetes这种调度器不熟悉，建议使用每个主机一个服务的模型，配合使用容器工件，这样可以灵活回退。

### 8.6. 不停机部署服务

三种常用的不停机部署模式：

* Rolling deploy 轮训部署，每次替换掉一个旧的
* Canaries 增加一个新实例，测试N+1的稳定性
* Blue-green deploys，并行两组服务，逐渐将请求转移到新版上

这三种模式都有一个基本操作：启动一个实例，使其处于运行状态，将流量切入。

## 9. 使用容器和调度器部署

* 使用容器将微服务打包成可部署的工件
* 如何在容器调度器Kubernetes上运行一个微服务
* Kubernetes核心概念，包括pods、services和replica sets
* 在Kubernetes上执行canary部署和回滚

Docker + Kubernetes

### 9.1. 服务容器化

本节内容：

* 为一个服务构建一个镜像
* 运行镜像的多个实例--或容器
* 将镜像推送到共享资源库

#### 9.1.1. Working with images

容器镜像可以继承。

在同一个机器上，如果一个父层被两个派生镜像共享，则只需要拉取一次。

#### 9.1.2. 构建你的镜像

使用公共镜像可能存在潜在的安全问题，特别是那些非官方的镜像，通常更新不及时。
可使用扫描工具（Clair）分析Docker容器镜像的安全性程度。该工具可以和持续集成管道集成到一起。

> https://github.com/coreos/clair

管理自己的基础镜像也是一个选择，但需要额外的时间投入，而且还要考虑团队的能力和安全方面的专业知识。

#### 9.1.3. 运行容器

启动多个实例后，可以使用nginx作为负载均衡的代理，将请求分发给实例。

#### 9.1.4. 存储镜像

可以使用Docker分布式开源项目自己搭建镜像registry，并与持续交付通道对接：

> https:// github.com/docker/distribution

也可以将Docker镜像保存为tarball文件，直接存储在标准的文件服务器。

简单做法是在https://hub.docker.com创建账号，并将Docker镜像推送到上去，Docker镜像名字的规则：

```
<registry>/<repository>:<tag>
```

### 9.2 部署到一个集群

容器调度器可以用来管理跨共享资源池的原子的、容器化应用的执行，因为这些容器都提供较强的资源隔离和统一的API。

微服务部署平台使用调度器的好处：

* 扩展性
* 健康检查
* releases across 任何数量的独立服务

容器调度器的工作流程：

* 开发者编写声明式指令指出要运行哪个应用--无状态长期运行的服务、一次性作业、有状态应用（如数据库）
* 指令发送到master节点
* master节点执行哪些指令，并将工作分发给其下的工作自己节点
* 工作自节点从合适的资源库拉取容器，并运行指定的应用

Kubernetes可以运行在很多地方--公有云、私有数据中心，或者作为一个管理服务。

本节的内容：

* 学习Kubernetes上的部署单元--pods
* 定义并部署一个单元的多个复制品
* 将请求路由给pods
* 部署一个新版的微服务
* 学习Kubernetes上的微服务间如何通信

本地版Kubernetes--Minikube
测试环境master和worker节点可以在同一个虚拟机上。
正式部署环境下，master和worker节点应该分别部署在不同的虚拟机上。

> https://github.com/kubernetes/minikube

如果使用私有数据仓库，需要在Minikube中配置访问权限。

#### 9.2.1. 设计和运行pods

一个pod是一个部署单元（unit），对应服务的一个实例。也是横向水平扩展的单位。

#### 9.2.2. 负载均衡

#### 9.2.3. A quick look under the hood

##### Master节点由四个组件组成

* API Server
* 调度器
* 控制器管理器
* 分布式key-value数据存储--etcd

##### Worker节点的组件

* 容易运行时（Docker）
* kubelet--与Kubernetes master交互，启动、停止、监控容器
* kube-proxy--提供网络代理，在不同的pod之间重定向请求

##### 观察状态变化

##### 理解Pods如何运行

* 1. 指示API Server使用kubectl创建一个新的副本集，存储在etcd上
* 2. 控制器管理器收到已创建通知
* 3. 控制器对比当前集群状态和新状态，确定是否需要创建新的pods，如果需要，则使用kubectl提供的模版创建pods
* 4. 调度器接收到新pod创建通知后，将其分配给合适的节点，然后再次通过API Server更新pod的定义（此时还没有真正运行应用程序）
* 5. pod一旦分配个一个node，API Server通知合适的kubelet，kubelet指示Docker运行容器。镜像下载，容器启动，kubelet开始监控操作，此时pods正式运行

#### 9.2.4 监控检查

默认情况下，Kubernetes为每个运行的pod执行轻量级的，基于进程的liveness检查。
如果liveness检查失败，Kubernetes会尝试重启容器（容器的重启策略未被设置成Never情况下）。

每个worker节点上的kubelet进程负责健康检查。这个进程会持续查询容器运行时，以证实是否需要重启容器。

只监控容器状态还不够，服务本身的出现问题时，调度器并不能识别，这可能导致服务路由给无响应节点，进而导致潜在的级联故障。为了避免这种情况的发生，调度去也需要持续检查容器内部的应用程序状态，确保live和ready。

Kubernetes可以通过配置probes来达到这个目的。

Probes的种类：

* HTTP GET请求
* 容器内的脚本执行
* TCP socket检查

#### 9.2.5. 发布新版本

#### 9.2.6. 回滚

#### 9.2.7. 连接多个服务

服务中不要硬编码端口和IP地址，去饮用其他协作者，应该通过名称访问。

Kubernetes集成了一个本地DNS服务，作为一个pod运行在Kubernetes master上。

名字的命名规则：

> {my-svc}.{my-namespace}.svc.cluster.local

## 10. 为微服务构建一个交付通道

* 为微服务设计一个持续交付通道
* 使用Jenkins和Kubernetes自动部署任务
* 管理临时（staging）环境和生产环境
* 使用功能标记和dark launches区别deployment和release

### 10.1. Making deploys boring

理想的微服务部署过程应该达到两个目标：

* Safety at pace 快速+安全
* Consistency 一致性

安全和速度之间要到达一个平衡--不能为了快速，而忽略安全；也不能为了安全，而投入大量的时间。

#### 10.1.1. 部署通道（pipeline）

持续交付在降低风险和提高速度之间达到了理想的平衡：

* 发布较小的提交集合有助于提高安全性，小的修改集更容易定位问题
* 提交验证的自动化通道提高了修改无瑕疵的可能

持续交付与持续部署不太一样，后者是每个经过验证的修改都可以自动部署到生产环境；前者是每个修改都能部署到生产环境，不管是否是开发团队和业务需要的。

通道的一般步骤：

* 提交代码
* 自动编译、构建
* 自动运行单元测试
* 自动打包存储到artifact资源库
* 自动部署到临时环境，测试服务
* 自动部署到生产环境

### 10.2. 利用Jenkins构建一个通道

通道通常由多个工具组合而成，包括服务的技术栈和要部署的目标平台。

本节涵盖的内容：

* 使用Jenkins编写复杂的部署通道
* 构建通道，构建、测试、部署服务到不同的环境
* 管理微服务的临时环境
* 跨多服务复用部署通道

#### 10.2.1. 配置构建通道

Jenkins应用由一个master节点和任意数量的agents组成。

#### 10.2.2. 构建镜像

Jenkins为Docker提供了Groovy DSL，可以代替命令行脚本：

> docker.build(imageName)

#### 10.2.3. 运行测试

在测试过程中，可将错误信息自动发送给项目组人员，或推送给PagerDuty这样的监控工具。

#### 10.2.4 发布工件

为了发布工件，如果使用私有的仓库，需要在Jenkins中配置 Docker registry的凭证，如果使用公有的仓库则不需要。

#### 10.2.5. 部署到临时环境

#### 10.2.6. 临时环境（staging env）

#### 10.2.7. 部署到生产环境

* 代码部署
* 回滚
* 冒烟测试

如果在staging阶段部署成功，接下来要做的是：

* 通道等待人工批准进行到生产环境
* 一旦批准，将先发布一个canary实例，帮助验证新构建面对真实生产流量时是稳定的
* 如果对canary实例的性能满意，通道可以将剩余的实例部署到生产环境
* 如果不满意，可以回滚canary instance

### 10.3. 构建可重用的管道步骤

微服务提供了服务的独立性和技术的趋同，但需要付出一些代价：

* 开发者很难在不同组间移动，技术栈不同
* 工程师定位不同服务的行为时更复杂
* 对于同一关注点的不同实现，需要投入更多时间（如部署、日志、监控）
* 人会在隔离状态下作出技术选择，造成局部风险

#### 10.3.1. 程序性和声明性构建通道

通道脚步的弱点：

* Specific
* Procedural
* Don't abstract internals

### 10.4. 低影响部署和功能发布的技巧

* dark launches
* feature flags

#### 10.4.1. Dark launches

A go-live strategy in which code implementing new features is released to a subset of the production environment but is not visibly, or only partially, activated. The code is exercised, however, in a production setting without users being aware of it.

一个上线策略

#### 10.4.2. 功能标记

指定的功能只对部分用户可用。局部内测

支持功能标记的库：

* Flipper http:// github.com/jnunemaker/flipper
* Togglz http://github.com/togglz/togglz

## 11. 构建一个监控系统

* 理解从运行中应用收集什么样的信息（signals）
* 构建一个监控系统，收集指标数据
* 学习如何使用收集的信号构建预警提醒
* 观察单个服务的行为，以及作为一个系统时之间的交互

虽不能先发制人，但可以快速响应，定位问题。

### 11.1. 强壮的监控栈

监控栈的组件：

* Metrics 指标
* Logs 日志
* Traces 轨迹

Metrics提供监控，Logs和traces提供观察

#### 11.1.1. 好的监控时分层的

在架构的client、boundary、services、platform四层都要实现监控。

不能只监控一个服务，而是要监控所有层，包括服务和底层基础设施。

监控方法应该能让你知道什么中断或降级了，以及为什么。你应该能够快速披露症状，并使用监控器确定原因。

#### 11.1.2. Golden signals

从面向用户的系统搜集的指标时，关注的四种golden signals：

* latency 延迟
* errors 错误
* traffic 流量状况
* saturation 饱和度

##### 延迟

延迟用来衡量从请求到服务完成请求的时间长短。
延迟需要和错误区分开。

##### 错误

注意区分错误状态和正确状态下的错误内容。

##### traffic

用于衡量系统的需求量：

* 每秒请求次数
* 网络I/O

##### 饱和度

在给定的点，衡量服务的能力，资源达到上限的趋势，如CPU、内存、网络带宽

#### 11.1.3. 指标的类型

##### 数量

* 请求数
* 错误数
* 每个HTTP代码数量
* 传输字节数

如果指标会降低的，不应该使用数量，而应该使用gauge（宽度）

##### Gauge 宽度

Gauge用于表示任意可上升或下降的数值：

* 数据库连接数
* 内存占用
* CPU占用
* 平均负载
* 服务异常操作数量

##### Histograms 直方图

* 请求延迟
* I/O延迟
* 每个回应的字节数

#### 11.1.4. 推荐实践

应该尽可能多的收集数据。

尽可能的用仪表盘展示数据。

### 11.2. 使用Prometheus和Grafana监控

* Prometheus (https://github.com/prometheus) ，指标收集
* Grafana (https://grafana.com)，展示，构建仪表盘，可连接多数据源--Graphite，InfluxDB，Prometheus

可以将StatsD格式指标数据转换到Prometheus，也可以用RabbitMQ接收指标数据到Prometheus。

Prometheus是从系统拉取数据，StatsD是将数据推送到收集服务。

#### 11.2.1. 建立指标集合基础设施


### 11.3. Raising sensible and actionable alerts

#### 11.3.1. 谁应该知道什么地方出错了？

预警信息应该按照紧急程度分类，有些问题需要引起马上注意，有些需要立即解决。

#### 11.3.2. 征兆，而非原因

当出现征兆，而非原因时也应该触发预警。

### 11.4. 观察整个应用

## 12. 通过logs和traces理解行为

* 将logs以一致性和结构化方法存储为机器可读格式
* 建立日志基础设施
* 通过traces和相关的IDs理解系统的行为

### 12.1. 理解跨越服务的行为

一致的日志格式有助于确保存储和处理数据的效率

### 12.2. 生成一致的、结构化的人可读日志

日志的种类：

* 应用日志
* 数据库日志
* 网络日志
* 性能数据--从底层操作系统收集的

#### 12.2.1. 日志记录中要包含有用的信息

* 时间戳 应尽可能详细，包括时区，跨时区时有用
* Identifiers 
* Source 标识来源
* 级别或分类

来源分为：

* Host
* class or module
* Function
* Filename

级别或分类：

* ERROR
* DEBUG
* INFO
* WARN

#### 12.2.2. 结构化和可读性

* 应该避免使用二进制编码的数据或任何人类无法理解的编码。
* 一条记录避免多行日志，因为在聚合工具中可能导致碎片，而丢失信息。

### 12.3. 为SimpleBan建立日志基础设施

ELK--Elasticsearch, Logstash, Kibana

#### 12.3.1. ELK- and Fluentd-based solution

Fluentd -- 开源日志收集系统

##### Elasticsearch

> www.elastic.co/products/elasticsearch

搜索和分析引擎，存储数据，索引数据，快速检索

##### Logstash

> www.elastic.co/products/logstash

服务器端处理通道，将从多个数据源汇集的数据，转换后发送个Elasticsearch，可以用Fluentd代替。

##### Kibana

> www.elastic.co/products/kibana

可视化UI，展示Elasticsearch数据

##### Fluentd

> www.fluentd.org

开源数据收集器，用于将数据从service推送到Elasticsearch。
它的好处是可以作为日志提供者，为Dockerfiles记录日志。

#### 12.3.2. 建立你的日志方案

#### 12.3.5. 记录正确的信息

在记录日志信息时，需要注意敏感信息的保密和风险问题，与个人相关的敏感信息尽量不收集或加密处理，否则可能违法GDPR的数据隐私法律。

### 12.4. 跟踪服务间的交互

OpenTracing API

分布式追踪的开放标准。

#### 12.4.1. Correlating requests: traces and spans

每个span包含以下信息：

* 一个操作名称
* 一个开始和一个结束时间戳
* 零个或多个span标签（key/value对）
* 零个或多个span日志（key/value对，带时间戳）
* 一个span context
* 一个或多个span引用

Jaeger 一个分布式tracing系统，符合OpenTracing

> www.jaegertracing.io

#### 12.4.2. 在服务中建立tracing

## 13. 构建微服务团队

* 微服务架构如何影响工程师文化和组织
* 构建高效微服务团队的策略和技巧
* 微服务开发中常见的陷阱
* 大型微服务应用中的最佳实践

### 13.1. 构建高效团队

随着组织的增长，将工程师分成独立的团队，将团队规模控制在一个的大小：

* 确保团队成员间沟通可控
* 孤立独立性和敏捷性时，更容易分清责任和界限

#### 13.1.1. Conway‘s Law

应用架构是组织架构的反应。

#### 13.1.2. 高效团队的原则

##### Ownership

Monolithic应用中，通常是 n:1，多个团队拥有一个服务，每个团队负责不同的层或者功能区域
微服务应用中，通常是 1:n，每个团队拥有多个服务

##### Autonomy

自治对扩展很重要。一个管理者控制多个团队将是一个挑战。

##### End-to-End Responsibility

### 13.2. 团队模型

* functional，按功能分组，有时限的项目（time-bound projects）
* cross-functionally， 长期项目目标

#### 13.2.1. 按功能分组

优点：

* 保证了沟通路径较短，可以高效的分享知识
* 相似的工作和方法组合在一起，提供了清晰的职业成长和技能发展

缺点：

* 所有权不清晰
* 缺少自主性
* 没有长期的责任
* Risk of Silos

#### 13.2.2. 跨功能分组

优点：

* 团队伴随业务价值，更容易实现业务能力
* 单个服务有明确的所属权
* 服务架构将反应出团队的低耦合和高内聚
* 不同团队能够协同，分享实践经验

跨功能团队能够更快的交付功能

#### 13.2.3. 设置团队边界

* 观察团队规模，一旦达到9人以上，团队工作的沟通成本开始增加
* 考虑协调性，如果协调不好，可能需要将团队拆分到其他组中

#### 13.2.4. 基础设施、平台和产品

#### 13.2.5. Who's on-call?

you build it, you run it

A successful on-call rotation should be:

* Inclusive--任何一个能做的，就应该做，包括VP和指导者
* Fair--占用额外时间应该有额外报酬
* Sustainable--可持续，足够的工程师，在工作和生活之间达到平衡，避免疲劳过度
* Reflective

#### 13.2.6. 分享知识

虽然自主团队能够加快开发进度，但也有几个缺点：

* 不同的团队可能在使用不同的方法重复解决同一个问题
* 团队成员减少了与其他团队成员的互动
* 团队成员可能在做局部决定时，没有考虑全局情况

解决办法：

* 按照功能分组
* 知道分享实践，如性能、安全

### 13.3. 微服务团队的推荐实践方法

#### 13.3.1. 微服务中变化的驱动力

* 底层框架和依赖可能因为性能、安全和新功能等需要升级
* 服务不再适合目标，如扩展能力
* 在服务或服务的依赖中发现了缺陷

#### 13.3.2. 架构的角色

架构师重点关注的内容：

* 应用应该符合组织的目标
* 技术选型在不同的团队间不应该有冲突
* 团队之间应该共享技术价值和期望
* Cross-cutting conerns，可观察性、部署、服务间通信
* 整个应用应该能够灵活面对变化，可扩展

架构师最好的出发点是：原则

#### 13.3.6. 文档

每个服务应该有四层文档：

* overviews 概述，架构的概要描述，团队成员和服务使用者的切入点
* contracts 合约，对外提供的API描述、依赖的传输机制
* runbooks 运行手册，常用操作的细节描述、失败情况描述
* metadata 元数据， 关于技术实现，开发语言、主要框架版本，支撑工具和部署URLs

开源项目文档工具：MkDocs

> www.mkdocs.org

文档很难及时更新，可以考虑根据应用状态自动生成，如从Swagger YML 文件生成合约文档。




