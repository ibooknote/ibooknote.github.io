= 《Docker in Action》阅读笔记

== Preface

容器编排器（container orchestrator）的主要目是跨主机集群运行模型化为服务的应用程序。

Kubernetes是最有名的容器编排器，但过于庞大。对于小型集群，使用Swarm足够，并且Swarm很适合同时开始学习编排和容器。

== about this book

第一部分，介绍Docker和容器特性，帮助理解如何使用Docker安装、卸载应用。如何在不同的容器配置下运行、管理、连接不同种类的软件。涵盖了每个Docker用户的必备技能。

第二部分，聚焦使用Docker打包和分发软件。Docker镜像的基础知识，文件大小、不同的打包和分发方法。

第三部分，浏览多容器项目和多主机环境。Docker Compose、Swarm

== 1. 欢迎使用Docker

内容概要：

* Docker是什么
* 容器介绍
* Docker如何解决问题
* 什么时候，在哪里，为什么使用Docker

需要动态扩展的服务软件，通过Docker部署可以降低对客户的影响。

容器能够更快的启动，并且比虚拟主机消耗更少的资源。

使用Docker，借助CI/CD技术能够构建更丰富的管道，并创建更强壮的功能测试环境。测试中的容器可以和生产环境有相同的软件。这样生产环境更容易修改，更快的迭代。

如果在本地开发环境使用Docker，可以降低成员入门时间。相同的环境可以使用版本控制，与软件保持一致，并随着软件个修改而更新。

使用Docker分发软件，可以降低用户安装和运行的难度。

Docker隔离了应用与系统之间的依赖，使得管理员可以注入特定环境下的配置，严格的控制对系统资源的访问。帮助管理员专注于高价值的活动。

Docker不是一个编程语言，也不是构建软件的框架。它是一个工具，帮助解决安装、移除、升级、分发、验证和运行软件的问题。

=== 1.1. Docker是什么？

* 开源项目
* 用于构建、运输、运行程序
* 一个命令行程序、一个后台进程，一组远程服务
* 为解决常见软件问题提供支持
* 简化软件的安装、运行、发布和移除
* 使用容器技术

==== 1.1.1. Hello World

*在CentOS上安装Docker引擎*

安装说明：

https://docs.docker.com/engine/install/centos/

三种安装方式：

* 设置Docker repositories，通过其进行安装。易于安装和升级，推荐使用
* 下载RPM包手动安装和升级，适用于不能访问互联网的的服务器上安装Docker
* 在测试和开发环境下，用户可选择使用自动脚本安装Docker，（生产环境不建议使用），其有以下潜在风险：
** 脚本需要root或sudo权限运行，运行之前应该严格检查脚本；
** 脚本会尝试侦测Linux发行版本并配置包管理系统。脚本不允许自定义安装参数，可能导致不支持的配置。
** 脚本会不经询问即安装所有依赖和推荐包。可能会安装大量的依赖包。 
** 脚本为提供指定安装Docker版本的功能，直接安装最后一个release版。
** 如果在主机上已使用其他方式安装，请不要用脚本安装。

*使用repository安装*

__第一步：设置Docker repository__

----
yum install -y yum-utils
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
----

__第二步：安装Docker引擎__

安装最新版Docker引擎和容器：

----
yum install docker-ce docker-ce-cli containerd.io
----

验证指纹：

----
060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35
----

安装指定版本的Docker引擎和容器

----
yum list docker-ce --showduplicates | sort -r
yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io
----

启动并运行Docker：

----
systemctl start docker
docker run dockerinaction/hello_world
----

dockerinaction/hello_world -- image/repository name

image镜像是文件和元数据的集合，元数据包括要执行的程序和其他相关配置细节信息。

Docker下载安装镜像之后，创建一个新的容器，并运行程序。

容器的运行状态直接与在其中运行的程序绑定在一起。如果程序运行，容器也在运行如果程序停止，容器也停止。重启容器将再次运行程序。

==== 1.1.2. 容器

容器原来的名字叫Jail（监狱），目标也由原来的限制文件文件系统范围变成了隔离进程，并只能访问允许的资源。

容器的使用已经有很长的时间，但构建容器面临很多挑战，Docker帮助解决了这个问题。运行在Docker上的任何软件都是运行在一个容器中。Docker利用已有的容器引擎提供一致的容器构建。

==== 1.1.3. 容器不是虚拟化

云原生时代，人们通常将虚拟主机当作部署单元。虚拟主机提供虚拟的硬件，要花费几分钟时间来创建，并且需要较多的资源开销，因为要运行整个操作系统。但启动的延迟使得它不适合just-in-time或者响应式部署。

Docker容器不使用硬件虚拟化。运行在Docker容器中的程序直接与主机Linux内核连接。它直接使用构建于操作系统内核中的容器技术。

虚拟主机提供了硬件的抽象，可以用来运行操作系统。而容器是一个操作系统功能。

==== 1.1.4. 在容器中运行软件可实现隔离

容器和隔离特征已经存在十多年，Docker使用Linux的命名空间（namespaces）和cgroups。Docker不提供容器技术，但它简化了容器技术的使用。

Docker在用户空间中包含两个程序：

* Docker引擎 -- 一直运行 
* Docker CLI -- 用户交互

Docker构建容器时使用10个主要的系统功能：

. PID 命名空间 -- 进程标识符和功能（capabilities）
. UTS 命名空间 -- 主机和域名
. MNT 命名空间 -- 文件系统访问和结构
. IPC 命名空间 -- 共享内存上的进程通信
. NET 命名空间 -- 网络访问和结构
. USR 命名空间 -- 用户命名和标识符
. chroot syscall -- 控制文件系统根路径
. cgroups -- 资源保护
. CAP drop -- 操作系统功能限制
. Security modules -- 强制访问控制

Docker使用这些在运行时构建容器，但使用另外一组技术来打包和运输容器。

==== 1.1.5. 运输容器

充当容器运输角色的组件被称为__镜像（image）__

Docker镜像是容器中运行的程序需要的所有文件的快照包。

使用Docker分发软件，分发的是镜像。镜像是Docker生态系统中的最小运输单元。

=== 1.2. Docker解决什么问题？

* 系统上运行多个应用时，如何防止互相干扰？
* 共同依赖的包升级或移除时会怎样？
* 移除时，能否记住原来安装的所有依赖

==== 1.2.1. 条理化

Docker通过容器和镜像将所有东西隔离，使得事情变得有条理。

==== 1.2.2. 提高可移植性

在任何系统上运行相同的软件。

Docker提高了每个程序的可移植性，不论是用哪种语言写的。

==== 1.2.3. 保护你的计算机

运行的程序可能存在异常行为或安全风险：

* 程序被攻击者修改
* 再厉害的开发者写的程序也会有bug
* 程序受到攻击后，可能做一些意外操作（sql注入）

=== 1.3. Docker为什么重要？

Docker提供了一层抽象。

Docker的重要性在于它使得容器对每个人都可用。使用它可以节省时间、金钱和精力。

第二个重要性在于软件社区采用容器和Docker有重要的推动力（Amazon, Microsoft, and Google）

第三个原因是，Docker已经为计算机实现了像应用商店为手机设备所做的那样。而Docker做的更好，跨平台、开放。

第四点，应用程序的安全隔离

=== 1.4. 在哪，什么时候使用Docker？

Docker几乎可以运行在任何地方。但并不能在桌面系统上运行macOS或Windows原生应用。

有些情况下不适合使用容器：

* 程序如果需要完全访问机器，则不适合使用容器
* 容器不是安全问题的完整解决方案，但可以阻止大部分类型的攻击

不应该使用不可信来源的软件，特别是当软件需要管理员权限时。这也意味着在共享环境下使用客户提供的容器是个坏主意。

=== 1.5. 大型生态系统中的Docker

* 容器编排
* 高可用集群
* 微服务生命周期管理
* 可视化

Docker子组件：

* runc
* libcontainerd
* notary

Kubernetes为在集群环境下，将服务编排成容器提供了一个扩展平台。它正成长为“数据中心操作系统”。

Kubernetes依赖容器引擎，如Docker。

Kubernetes扩展能力很强大，但学习成本高，并且需要持续的付出。

=== 1.6. 通过Docker命令行获取帮助

=== 总结

== 第一部分--进程隔离与环境无关的计算

这部分都以现成的软件为例来讲解容器的基础操作和进程隔离的基本控制。

=== 2. 在容器中运行软件

概要：

* 在容器中运行可交互的、常驻内存的终端程序
* Docker基础操作和命令
* 隔离程序、注入配置
* 在一个容器中运行多个程序
* 持久的容器和容器的生命周期
* 清理

off-the-shelf -- 现成的

==== 2.1. 控制容器：构建一个网站监视器

本节内容：

* 创建后台运行的容器和交互容器
* 查看系统上的容器列表
* 查看容器日志
* 停止和重启容器
* 为容器重新挂载终端
* 从挂载的容器中离开

===== 2.1.1. 创建和启动一个新容器

Docker镜像包含了运行一个软件所需的所有东西。

从公共Docker Hub下载、安装、启动NGINX容器：

----
docker run --detach \
    --name web nginx:latest
----

=== 3. 简化软件安装

=== 4. 处理存储和volumes

=== 5. 单一主机网络

=== 6. 通过资源控制限制风险

== 第二部分--软件打包发布

=== 7. 将软件打包成镜像（images）
=== 8. 使用Dockerfiles自动构建镜像
=== 9. 公有和私有软件分发
=== 10. 镜像管道

== 第三部分--高级别抽象和编排

=== 11. 服务与Docker和Compose
=== 12. First-Class配置抽象
=== 13. 使用Swarm在Docker主机集群上编排服务
