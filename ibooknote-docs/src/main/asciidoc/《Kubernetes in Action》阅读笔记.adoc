= 《Kubernetes in Action》阅读笔记

== 第一部分 概述

== 1. Kubernetes介绍

微服务的缺点：

* 当服务变多时，服务间关系增多，人工维护、配置复杂，可维护性降低
* 对调用难以跟踪、调试，因为它们跨多服务器和进程（已可以使用分布式追踪系统Zipkin解决）

单体应用与微服务对环境需求的区别：

* 微服务不但可以单独部署，也可以单独开发，项目组之间不会互相干扰
* 不同服务依赖的相同软件包可以根据各自的需要使用不同的版本

== 2. 使用Docker和Kubernetes的第一步

=== 2.1. 创建、运行、和共享容器镜像

在Docker容器中运行的进程，在宿主主机中也能查到相应的进程，但进程ID不同，容器中为其分配了新的ID。

通过docker命令参数 __exec -it [container name] bash__ 进入运行中容器内部，查看容器内部情况，使用方式和linux类似，参数 -i 表示标准输入开启，可以输入shell命令；-t 表示开启伪终端TTY，用于显示控制台输出信息。

=== 2.2. 创建Kubernetes集群

创建Kubernetes集群的集中方法：

* 多节点集群安装，参考 http://kubernetes.io 详细文档
* 在本地开发机上安装单节点Kubernetes，Minikube
* 运行于Google Kubenetes Engine（GKE）上的集群
* 使用kubeadm工具安装集群，介绍使用VM安装三节点集群
* 使用kops在AWS上安装Kubernetes集群 http://github.com/kubernetes/kops 

==== 2.2.1. 使用Minikube

== 第二部分 核心概念

== 3. Pods：在Kubernetes上运行容器

=== 3.1. Pods介绍

当一个pod上运行多个容器时，它们必须运行在单个工作节点上，同一个pod永远不会跨越到多个节点。

==== 3.1.1. 理解我们为什么需要pods

__理解为什么运行多个容器比在一个容器上运行多个进程更好__

容器设计的初衷是在每个容器上运行一个进程（进程自己扩展出的子进程除外）。如果在同一个容器上运行多个无关的进程，你必须负责看管所有进程的运行和它们的日志。并且需要一个机制可以重启单个进程。并且，这些进程会将日志输出到同一个标准输出，所以你必须花时间分辨出哪个进程对应哪些日志。