= 《Java 8 in Action》阅读笔记

== Part 1 基础

Java的主要变化：

* lambda表达式
* 方法引用
* 流（streams）
* 默认方法

=== 1. Java 8：为什么要关心？

内容概要：

* Java为什么还在变
* 改变计算的背景：多核和处理大数据集
* 发展的压力：新的架构体系更倾向于函数式风格，而不是命令式风格
* 介绍Java 8的核心功能：lambdas、streams、默认方法

Java 1.0开始有线程和锁，Java 5增加了线程池和并发集合，Java 7增加了fork/join框架，Java 8有新的更简便的方法。

匿名类可以实现代码参数化等同的功能，但没有lambda表达式简洁。

==== 1.1. Java为什么仍在变化？

新的语言出现，旧的语言要么被替代，要么进化。

===== 1.1.1. Java在编程语言生态系统中的位置

面向对象编程语言

===== 1.1.2. Stream处理

第一个编程概念：流处理

*stream* 

一个stream是一个数据元素序列，概念上是在一个时间点产生的。程序可以从一个输入流一个一个的读取元素，类似的也可以将其写到输出流。一个程序的输出流可以是另一程序的输入流。

Java 8增加的Streams API，有很多方法可以连接起来形成一个复杂的管道，类似Unix命令的管道传递。另一好处是Java 8可以在多个CPU核上透明的运行流的管道操作。

===== 1.1.3. 将代码传递给行为参数化方法

第二个编程概念：传递代码片段

`behavior parameterization`

===== 1.1.4. 并行性和共享可变数据

第三个编程概念

函数式编程的基石：

* 没有共享可变数据
* 传递方法和函数代码给其他方法

===== 1.1.5 Java需要进化

==== 1.2. Java中的函数（Functions）

Java 8中增加了函数作为新形式的值，促进了Streams的使用。

Java 8程序中可以操作的值：

* 基础类型
* 对象
* 函数

===== 1.2.1. 方法和lambdas成为一等公民

Java 8中将方法作为值，形成了其他功能的基础（如Streams）。

方法引用(*::*)--use this method as a value

*Lambdas* -- 匿名函数

Java 8中允许具名方法作为一等公民，当作value来使用，也允许将函数作为value，包括lambdas。

===== 1.2.2. 传递代码：一个例子

Predicate

===== 1.2.3. 从传递方法到lambdas

方法还是要事先定义，而lambdas可在使用时定义，适合仅使用一两次的情况。代码看起来更简洁。

Java设计者可以在范型库中增加过滤器来处理Predicate<T>，但为了更好的发挥并行性，他们没有那样做。Java 8中采用了一整套全新的类似Collections的API，叫做Streams，包含类似filter的详细操作集合。

==== 1.3. Streams

几乎每个Java应用都要创建并处理集合（collections）。

与Collections API相比，Streams API提供了完全不同的处理数据的方法。使用collection，开发者需要自己管理迭代过程，这种迭代方式被称为外部迭代（external iteration）；而使用Stream API，开发者不需要考虑元素的循环，数据处理发生在库的内部，我们称之为内部迭代（internal iteration）。

===== 1.3.1. 多线程很难

利用Threads API编写多线程代码有一定难度。必须考虑到**__线程能够同时访问和更新共享变量__**。

Java 8同时解决了两个问题：

* 集合的处理
* 多核利用的难题

Streams API的第一个设计驱动力是：有许多数据处理模式，基于一定的标准对数据进行过滤，提取数据、数据分组等等。

第二驱动力是这些操作经常可以并行化：

. Fork -- 每个CPU分取列表的一部分进行处理--**__forking step__**
. Filter -- CPU对各自负责的列表进行过滤
. Join results -- 其中一个CPU负责将结果联合到一起

Streams API的行为非常类似Collections API：二者都提供了访问序列数据的功能。但他们的区别是：

* Collections更多的是关于存储和访问数据
* Streams更多的是描述如何对数据进行计算

最关键的一点是Streams允许并鼓励一个Stream中的元素并行处理。

*Java中的并行性和没有共享可变状态*

Java 8中的两个魔法子弹：

* 分区处理 -- 库将一个大的stream分割成几个小的streams并行处理
* 传递给库方法的方法没有交互

==== 1.4. 默认方法

Java 8中增加的默认方法功能，很大程度上支持了库设计者们能够写出更具可发展的接口。

为了兼容已存在的代码实现，Java 8使用了新的关键字**__default__**，在接口中制定默认方法实现。

==== 1.5. 其他来自函数式编程的好主意

常用的函数式语言（SML、OCaml、Haskell）提供了额外的构造来帮助开发者。其中之一是避免使用null，而改用更具描述意义的数据类型。

Java 8中有一个Optional<T>类，可以帮助避免空指针异常。它是一个容器对象，可能包含值，也可能不包含。

第二个亮点是pattern matching模式匹配。

模式匹配的两种含义：

. 数学或函数式编程中的函数定义概念
. 正则表达式匹配

本文中是第一种。

Java 8中没有完全支持模式匹配。

注： `模式匹配需要进一步学习，没有太看明白`

==== 1.6. 总结

本章主要概念：

* 语言生态系统中，一种语言要么进化，要么淘汰
* Java 8增加的核心概念和功能都是为了写出更高效、简洁的程序
* 现有的Java编程实践并未完全为多核处理器提供支持
* 函数是first-class values，记住方法可以作为函数值传递，以及如何编写匿名函数（lambdas）
* Streams概括了Collections的许多方面，但代码更刻度，并且允许并行处理
* 可以在接口中使用默认方法来提供方法体，如果实现类不实现该方法，可直接使用默认方法体
* 其他来源于函数式编程的ideas，包括处理null和模式匹配

=== 2. 以行为参数化传递代码

概要：

* 应对不断变化的需求
* 行为参数化
* 匿名类
* lambda表达式预览
* 真实例子：Comparator、Runnable、GUI

行为参数化（Behavior parameterization）是一种软件开发模式，用以处理频繁的需求变更。

==== 2.1. 应对需求变化

编写能够应对需求变化的代码并不容易。

===== 2.1.1. 第一次尝试：过滤绿苹果

===== 2.1.2. 第二次尝试：参数化颜色

DRY -- don't repeat yourself

===== 2.1.3. 第三次尝试：使用每个能想到的属性进行过滤

无法应对变化。

==== 2.2 行为参数化

一种可能的解决方案：将选择标准模型化

predicate -- 断言

strategy design pattern 策略设计模式 -- 定义并封装一些算法，运行时选择一个算法

*behavior parameterization* -- 告诉方法携带多个行为（或策略）作为参数，并在内部使用他们完成不同的行为。

===== 2.2.1. 第四个尝试：使用抽象标准过滤

behavior parameterization的好处：将集合迭代的逻辑与作用在每个元素上的过滤和行为分隔开。

行为参数化这个概念应该作为创建灵活API的工具集中的一员。

==== 2.3. 处理冗长（Tackling verbosity）

匿名类（anonymous classes） 可同时声明和实例化。

===== 2.3.1. 匿名类

匿名类类似局部类，但没有名字。

===== 2.3.2. 第五次尝试：使用匿名类

但匿名类还是不够好，略显笨重，因为占用了太多代码空间。

===== 2.3.3. 第六次尝试：使用lambda表达式

lambda表达式既简洁又灵活。

===== 2.3.4. 第七次尝试：List类型的抽象

==== 2.4. 真实例子

行为参数化模式类食欲策略设计模式。

===== 2.4.1. 使用Comparator排序

Comparator接口实现与lambda表达式的对比。

===== 2.4.2. 使用Runnable执行代码块

多线程接口Runnable与lambda表达式的对比。

===== 2.4.3. GUI事件处理

事件处理器与lambda表达式的对比。

==== 2.5. 总结

* 行为参数化是一个方法可以携带多个不同的行为作为参数，在内部使用他们完成不同的行为。
* 行为参数化使得代码能够适应需求变化，在未来介绍工程师时间。
* Java 8以前使用匿名类有些帮助，可以避免声明多个具体类
* Javva API包含很多能够被不同行为参数化的方法，包括排序、线程、GUI处理器

=== 3. Lambda表达式

概要：

* Lambdas简述
* 在哪里以及如何使用lambdas
* The execute around pattern
* 函数式接口，类型引用
* 方法引用
* 组合lambdas

lambda表达式可以用一种更简洁的方式展示行为或者传递代码。可以将其当作匿名函数（anonymous functions）。

==== 3.1. Lambdas简述

lambda表达式没有名字，但有一个参数列表，一个body，一个返回类型，也有可能有个异常列表：

* Anonymous -- 没有名字
* Function -- 因为它不像method那样与特定类有关
* Passed around -- 可以当作参数传递给方法或存储在变量中
* Concise -- 少写很多代码

**__lambda__** 一词来源于学术系统 lambda calculus，用于描述计算。



== Part 2 函数式数据处理

=== 4. 介绍streams

=== 5. 使用streams

=== 6. 使用streams收集数据

=== 7. 并行数据处理和性能

== Part 3 高效的Java 8编程

=== 8. 重构、测试和调试

=== 9. 默认方法

=== 10. 使用Optional代替null

=== 11. CompletableFuture：可组合的异步编程

=== 12. 新的日期和事件API

== Part 4 Beyond Java 8 超越

=== 13. 函数式思维

=== 14. 函数式编程技术

=== 15. 混合使用OOP和FP：Java 8于Scala笔记

=== 16. 结尾，Java的下一步