= Software Architecture in Practice, 4th Editon

== 前言

为什么要写第四版？软件架构是否已经过时？

随着软件技术的发展，云基础设施、微服务、框架的出现，人们可能以为不再需要架构知识，认为今天的架构师就是从丰富的工具和基础设施中选出合适的来使用它们。

架构和20年前一样至关重要：

1. 需求的快速增长，架构师面临更多的功能需求和bug修复以及客户、竞争对手的压力。如果架构师不注意他们的系统的模块化设计，系统很快就会变得难以理解，难以修改和调试，并最终拖累业务。
2. 当系统中的抽象级别提高时，我们通常会使用更多的完善的服务，很少再去理会它们是如何实现的 -- 我们被要求创建的系统很快会变得十分复杂。架构始终是关于如何驯服复杂性的，所以离不开架构。
3. 信息系统的特性迅速增长，意味着没有人能理解真实世界系统的所有方面。
4. 尽管有很多工具能使很多工作自动化完成 -- 如k8s中的 编排、部署、管理。单我们仍然需要理解这些系统中我们所依赖的高质量特性。当把这些系统组合到一起时，我们需要理解它们有用的新特性。没有架构师的指导，这种组合很容易失败。

== 第一部分：介绍

== 1. 软件架构是什么？

== 2. 软件架构为什么重要？

如果架构是答案，那问题是什么？

== 3. 理解质量属性

== 第二部分：质量属性（quality attributes）

== 4. 可用性

== 5. 可部署

== 6. 能源效率

== 7. 可集成

== 8. 可修改

== 9. 性能

== 10. Safety

== 11. Security

== 12. 可测试

== 13. 可用

== 14. 质量属性间的配合

== 第三部分：架构方案

== 15. 软件接口

== 16. 可视化

== 17. 云和分布式计算

== 18. 移动系统

== 第四部分：可扩展的架构实践

== 19. 架构上的重要要求

== 20. 设计一个架构

== 21. 评估一个架构

== 22. 记录一个架构

__Documentation is a love letter that you write to your future self. —Damian Conway__

文档是写给未来自己的情书。

只创建架构是不够的，还要与架构的利益相关者进行沟通。描述架构的信息必须足够详细，没有歧义，合理的组织好内容，使得其他人能够更快的找到和更新需要的信息。

文档对架构师来说，今天代表架构师回答关于架构的上百个问题；明天，当忘记忘记软件架构的细节（包括架构师自己），或者当架构师离开项目，其他人来时，代表架构师向他们解释；

最好的架构师不是因为“需要”才制作文档，而是认为对高质量的产品来说，它是必不可少的。

架构师也需要将文档看作是给他们自己的交付物。经过仔细考虑的文档能够使设计过程更顺畅，更系统化。不论是六个月的设计阶段还是六天的敏捷冲刺，文档能够在架构设计过程中帮助架构师验证架构设计。

文档不是必须生成物理的，打印的书一样的资料。在线文档如wiki，能够引发讨论、反馈和搜索，对架构文档来说更合适。文档和设计不是独立的两个步骤，他们是同一份工作。

=== 22.1. 架构文档的使用与受众

架构文档必须服务于多种目的。对新加入团队的人，它应该能够快速的访问和理解。应该能够作为构建和讨论的蓝皮书，应该有足够的信息作为分析的依据。

架构文档既可以当作规范，也可以当作记录。对于一些受众来说，它应该规定什么是正确的，作为做决定的约束。对于其他一些受众来说，它描述了什么是正确的，重新了解系统设计所做的决定。

*架构文档的四种用途*

1. 架构文档作为一种培训手段 -- 向新人或外部分析人员，以及新架构师介绍系统。
2. 架构文档作为 利益相关人之间沟通的主要手段。
3. 架构文档作为系统分析和构建的基础 -- 它必须包含必要的信息，用于评估各种特性，例如安全性、性能、可用性、可修改性。
4. 当事件发生时，架构文档可以作为检验的根据。

随着时间的推移，文档要想持续提供价值，必须保持更新。

=== 22.2. 符号

不同等级和形式的视图需要使用不同的符号来记录。初略的说，有三种类型的符号：

* 非正式符号 -- 使用PowerPoint或白板绘制图形和线条，自然语言描述特征，不能进行正式的分析。
* 半正式符号 -- 使用标准的符号表达视图，包括规定的图形要素和构建规则，但不提供完整的语义。UML和它的系统引擎 SysML 属于这一来符号。
* 正式符号 -- 描述视图的符号具有简洁的语义。可以进行语法和语义的正式分析。架构描述语言 ADLs，同时提供图形词汇和底层语义用于展现架构。支持自动分析和生成代码，实际上这种正式符号很少使用。

通常，越正式的符号需要花更多的时间和精力去创建和理解，但可以减少歧义，有更多的机会进行分析。相反，越不正式的符号越容易创建，但提供更少的保证。

不论正式与否，需要记住的一点是不同的符号适合表达不同类型的信息。

=== 22.3. 视图

视图（View）应该算是软件架构文档中最重要的概念。

视图 -- 是对一组系统要素和他们之间的联系的描述。并非所有类型的要素，而是特定类型的。

不同的视图支持不同的目标和用途。应该记录什么样的视图依赖于如何使用文档。不同的视图强调不同的系统要素和关系。

视图的选择是由设计中的特定模式来决定的。以下是三种基于结构的视图和一种新类型的质量视图：

==== 模块视图

模块间的关系包括：

* is-part-of
* denpends-on
* is-a

模块结构通常决定了系统的一部分发生变化会对其他部分有什么影像，进而决定了系统的可修改性、可移植性和重用性。

任何软件架构文档，都应该至少有一个模块视图才算完整。

模块视图的特点：

* 要素 -- Modules 模块，软件的实现单元，提供一组内聚的职责
* 关系 
** Is-part-of -- 定义整体与局部之间的关系
** Depends-on -- 定义两个模块间的依赖关系
** Is-a -- 定义更特殊模块与更通用模块间的父子关系
* 约束 -- 不同的模块视图可能利用拓扑约束，例如限制两个模块间的可见性
* 用法
** 构造代码的蓝皮书
** 对变化产生的影响的分析
** 计划增加开发
* 需求跟踪分析
* 系统功能与代码结构间的联系
* 工作安排的定义、实现调度，和预算信息
* 展示数据模型

模块包括以下属性：

* 名称 -- 描述模块在系统中的角色
* 职责 -- 用于标识模块在整个系统中的角色。应该能够描述的足够详细
* 实现信息 -- 模块是实现单元。
** 映射到源代码单元
** 测试信息
** 管理信息
** 实现约束
** 变更记录

模块视图无法推断运行时行为，它只是软件功能的静态部分。模块视图不能用于性能、可用性，和其他运行时质量的分析。为了达到这个目的，我们应该借助组件和连接器视图、分配视图。

==== 组件和连接器视图（C&C）

组件要素：进程、服务、对象、客户端、服务器、数据存储

连接器要素： 连接、协议、信息流

样例：

* client-server
* 微服务
* 进程间通信

连接器的表现形式：

* 服务调用
* 异步消息队列
* 事件多播
* 管道
* order-preserving 数据流

连接器不一定是二元的。publish-subscribe 连接器可以有任意数量的发布者和订阅者。

C&C视图中的关系主要是附属（attachment）

C&C 视图原属的的属性：

* 名称
* 类型
* 可靠性 -- 一个给定的组件或连接器可能的失败是什么？
* 性能 -- 组件在什么样的负载下提供什么样的响应时间？连接器的带宽、延迟、吞吐量、缓存大小。
* 资源需求
* 功能
* 安全
* 并发
* 运行时可扩展性 -- 消息结构是否支持可进化数据转换？连接器能否适配处理新消息类型？

C&C视图的特点：

* 要素
** 组件 -- 主要处理单元和数据存储
** 连接器 -- 组件之间的交互路径
* 关系 -- 归属：组件与连接器相关联以生成图形
* 约束 -- 组件只能归属于连接器，连接器只能归属于组件
** 只能在组件与连接器之间建立附属关系
** 连接器不能独立出现；一个连接器必须归属于一个组件
* 用法 -- 展示系统如何工作
** 通过运行时要素的特定结构和行为指导开发
** 帮助推断运行时系统的质量属性，例如性能和可靠性

*C&C视图的符号*

给每个组件类型和每个连接器类型赋予一个独立的符号，然后在图例中列出每个类型的含义。

UML组件比较适合 C&C 组件，因为他们能够为重要信息提供直观的描述，例如接口、属性、行为。UML组件还能区分组件类型和组件实例，这对定义特定视图组件类型很有用。

==== 分配视图（allocation view）

分配视图用于描述软件单元与一个环境中的要素之间的映射关系。

分配视图的特性：

* 要素 -- 软件要素和环境要素。软件要素具有环境要求的属性。环境要素有提供给软件的属性。
* 关系 -- allocated-to 一个软件要素分配个一个环境要素。
* 约束 -- 因视图而异
* 用法
** 用于推断性能、可靠性、安全性
** 用于推断团队的分布式开发和工作的分配
** 用于推断软件的并发访问
** 用于推断系统安装的形式和机制

==== 质量视图

模块、C&C，和分配视图都是结构性视图：主要用于展示架构师设计架构的结构，以满足功能和质量属性需求。

质量视图 通过提取结构性视图中的相关部分，并将他们打包到一起：

* 安全视图 -- 衡量架构的安全性
* 通信视图
* 异常或错误处理视图
* 可靠性视图
* 性能视图

=== 22.4. 组合视图

组合视图包含的要素和关系来至两个或多个其他视图。可使读者从整体上理解系统的架构。

几种组合方式：

* 多种C&C视图组合
* 部署视图与C&C视图组合
* 分解视图和工作分配、实现、使用或者分层视图

=== 22.5. 记录行为

记录行为的两种符号：

* trace-oriented
* comprehensive

记录轨迹的四种符号：

* 用例 -- 描述参与者如何使用系统完成他们的目标
* 时序图 -- 展示元素实例之间的交互序列。二维：垂直方向展示时间，水平方向展示各种实例。
* 通信图
* 活动图

时序图中无法明确展示并发，可以使用activity diagrams。

=== 22.6. 视图背后

除了视图和行为以外，一个架构的全面信息还包括以下项目：

* 视图间的映射 -- 展示视图间的关系能让读者深刻的理解架构的整体工作。
* 记录模式 -- 文档中应该记录架构采用的模式（采用的理由）
* 一个或多个context diagrams -- 描述视图的范围，展示系统或子系统如何与环境交互
* 可变性指南 -- 在视图中展示架构可变化的点
* Rationale -- 依据，设计产生的原因
* 术语表和缩略词表 -- 使用者能在同一种语言下交流（领域语言）
* 文档控制信息 -- 版本，变更记录

=== 22.7. 记录依据（Rationale）

设计决定：

* 设计概念的选择
* 依据选择的设计概念创建结构
* 在要素之间建立联系，定义接口
* 分配资源

几个问题：

* 做决定的依据是什么？
* 谁做了什么？
* 为什么抄近路？
* 为何做出折中？
* 做出什么样的假设？

=== 22.8. 架构利益相关者（Stakeholders）

关键的利益相关者：

* 项目经理 -- 模块视图、分配视图、顶级context diagrams
* 开发团队成员 -- 模块视图、C&C视图、分配视图
* 测试人员和集成人员
* 其他系统的设计者
* 运维人员
* 最终用户
* 分析师
* 基础设施支持人员
* 未来架构师

=== 22.9. 实际要考虑的方面

==== 建模工具

==== 在线文档、超文本、wiki

wiki可以创建共享文档，很多相关人员都可以参与。

==== 遵循一个版本策略

==== 架构记录需要动态变化

* 记录系统的所有版本
* 记录架构允许以何种方式修改
* 自动生成接口文档

==== 可追溯性


=== 22.10. 总结

编写架构文档的黄金法则：Know your reader

要知道架构文档的意义、用途和受众。



=== 22.11. 引申阅读

=== 22.12. 问题讨论

== 23. 管理架构债务

== 第五部分：架构和组织

== 24. 项目中架构师的角色

== 25. 架构能力

== 第六部分：结论

== 26. 未来一瞥：量子计算